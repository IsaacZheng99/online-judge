# 一种非严格意义dp的做法

## 1. 分析题意

根据题意以及给出的两个示例结果，比较容易朝dp的方向去想，例如：n为2时的每一个字符串都是由n为1时的每一个字符串再添加一个字符组成的，而能够添加哪些字符取决于n为1时字符串的最后一个字符（如果是'a'，那么可以添加5个字符，如果是'e'，则可以添加4个字符），有了递推关系，我们再按动态规划五步曲尝试看能否用dp解答本题。

## 2. 动态规划五步

### 2.1 确定dp数组以及下标的含义

- 比较直观的可以从两个方面定义dp数组：长度为n时所有满足条件的字符串列表，或者长度为n时满足条件的字符串数量。但根据我们分析题意的过程，**字符串长度加1时，只需要考虑前一个长度的字符串的最后一个字符是什么**，这样我们可以对字符串进行分组，例如：
  - 对于n = 1的情况，我们认为 **'a'，'e'，'i'，'o'，'u'** 这五个字符串是**一组**的，它们可以生成的长度为2的字符串数量分别为 **5，4，3，2，1** ，我们记**最大值5**，在计算时从1累加到最大值5。
  - 对于n = 2的情况，我们认为 **'aa'，'ae'，'ai'，'ao'，'au'** 这五个字符串是**一组**的（这5个字符串就是n = 1时的'a'字符串生成的），同理，它们分别生成长度为3的字符串的数量为 **5，4，3，2，1** ，我们仍然记**最大值5**。而对于'e'，'i'，'o'，'u'生成的长度为2的字符串，又能分别生成长度为3的字符串的数量为(4、3、2、1)，(3、2、1)，(2、1)，(1)，同样地我们还是记最大值4、3、2、1。
- 那么我们可以这样定义dp[i]：长度为i + 1的满足条件的字符串，按照上述描述分类，可以生成字符串数量的最大值的列表。（这里笔者也不太好用自然语言去描述了，但是个人认为上面的n为1和2时的举例说明还是比较清晰的，或者大家可以将这个过程想象成一棵多叉树，如果表述还是不太清楚，可以接着看后续的公式部分和代码实现）

### 2.2 确定递推公式

- 根据2.1中的定义，我们可以得出这样的递归公式（其实笔者写到这里已经不知道这算不算dp了，因为没有直接的转换公式）：

  ```python
  for iMaxCount in lDp[i - 1]:
      for iCount in range(iMaxCount, 0, -1):  # 这里用倒序，输出的列表会更直观
          lDp[i].append(iCount)
  ```

- 我们遍历dp[i - 1]中”每一组“中的最大值，然后从1取到这个最大值，累计到dp[i]中。

### 2.3 dp数组初始化

- 根据递推公式，我们直接初始化n = 1的情况即可。
- 即：dp[0] = [5]。（注意每一个dp项是一个列表，列表的每一项就是”一组“，用于生成）

### 2.4 确定遍历顺序

- 从递推公式可以看出，dp[i]是依赖于dp[i - 1]的，所以从前往后遍历即可。

### 2.5 举例推导dp数组

- i = 0时，dp[0] = [5]。
- i = 1时，dp[1] = [5, 4, 3, 2, 1]。
- i = 2时，dp[2] = [5, 4, 3, 2, 1, 4, 3, 2, 1, 3, 2, 1, 2, 1, 1]。这里前五个元素54321就是由dp[1]的第一个元素5得来的，紧接着4321就是由dp[1]的第二个元素4得来的，依次往后。

## 3. 代码实现

```python
class Solution:
    def countVowelStrings(self, n: int) -> int:
        lDp: List = [[] for _ in range(n)]
        lDp[0] = [5]
        for i in range(1, n):
            for j in lDp[i - 1]:
                for k in range(j, 0, - 1):
                    lDp[i].append(k)
        return sum(lDp[n - 1])
```

